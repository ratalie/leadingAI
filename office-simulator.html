<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Darshana Office Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        #dialogue-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 20px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
        }

        #dialogue-box h3 {
            margin: 0 0 10px 0;
            color: #D97356;
        }

        #dialogue-content {
            margin: 10px 0;
            line-height: 1.6;
            max-height: 200px;
            overflow-y: auto;
        }

        .dialogue-option {
            background: #f0f0f0;
            border: 2px solid #D97356;
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .dialogue-option:hover {
            background: #D97356;
            color: white;
            transform: translateX(5px);
        }

        #custom-question-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #ddd;
        }

        #custom-question-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #D97356;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            box-sizing: border-box;
        }

        #custom-question-submit {
            background: #D97356;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            margin-top: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        #custom-question-submit:hover {
            background: #c85a3f;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #custom-question-submit:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(217, 115, 86, 0.3);
            border-radius: 50%;
            border-top-color: #D97356;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .instruction {
            opacity: 0.8;
            font-size: 14px;
            margin-top: 10px;
        }

        #interaction-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            font-size: 14px;
        }

        .floating-text {
            position: absolute;
            color: #ff0;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 2s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-overlay">
        <h2>Darshana Co-Founders Office</h2>
        <p style="font-size: 20px;">üöÄ Meet the Darshana Founders</p>
        <p>Use WASD to move around</p>
        <p>Arrow keys or mouse to look left/right</p>
        <p>Press E to interact</p>
        <p>Press SPACE to dance</p>
        <p>Press ESC to close dialogs/release mouse</p>
        <p class="instruction" style="margin-top: 10px;">üí° Type custom questions when talking!</p>
    </div>

    <div id="dialogue-box">
        <h3 id="dialogue-name">Name</h3>
        <div id="dialogue-content">Content</div>
        <div id="dialogue-options"></div>
        <div id="custom-question-container">
            <p style="margin: 5px 0; font-size: 14px; opacity: 0.8; text-align: center;">‚îÅ‚îÅ‚îÅ Or ask your own question ‚îÅ‚îÅ‚îÅ</p>
            <input type="text" id="custom-question-input" placeholder="Ask anything! e.g., 'What's your vision for Darshana?' or 'Tell me about AI in hiring'" maxlength="200">
            <button id="custom-question-submit">Ask Question</button>
        </div>
    </div>

    <div id="interaction-prompt">Press E to talk</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        scene.fog = new THREE.Fog(0xf5f5f5, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Floating text effect
        function createFloatingText(text, worldPos) {
            const screenPos = worldPos.clone();
            screenPos.project(camera);

            const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

            const div = document.createElement('div');
            div.className = 'floating-text';
            div.textContent = text;
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            document.body.appendChild(div);

            setTimeout(() => div.remove(), 2000);
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Floor with pattern
        const floorGeometry = new THREE.PlaneGeometry(40, 40);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0xdcdcdc,
            roughness: 0.7,
            metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Add floor tiles pattern
        const tileGeometry = new THREE.PlaneGeometry(2, 2);
        const tileMaterial1 = new THREE.MeshStandardMaterial({ color: 0xe8e8e8 });
        const tileMaterial2 = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });

        for (let x = -20; x < 20; x += 2) {
            for (let z = -20; z < 20; z += 2) {
                const tile = new THREE.Mesh(tileGeometry, ((x + z) / 2) % 2 === 0 ? tileMaterial1 : tileMaterial2);
                tile.position.set(x + 1, 0.01, z + 1);
                tile.rotation.x = -Math.PI / 2;
                tile.receiveShadow = true;
                scene.add(tile);
            }
        }

        // Walls with windows
        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xf8f8f8,
            roughness: 0.9
        });

        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0x87ceeb,
            transparent: true,
            opacity: 0.3,
            roughness: 0.1,
            metalness: 0.5
        });

        // Back wall with windows
        const backWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        backWall.position.set(0, 5, -20);
        backWall.receiveShadow = true;
        scene.add(backWall);

        // Add windows to back wall
        for (let x = -15; x <= 15; x += 10) {
            const window = new THREE.Mesh(
                new THREE.PlaneGeometry(4, 3),
                windowMaterial
            );
            window.position.set(x, 5, -19.9);
            scene.add(window);
        }

        // Side walls
        const leftWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        leftWall.position.set(-20, 5, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(
            new THREE.PlaneGeometry(40, 10),
            wallMaterial
        );
        rightWall.position.set(20, 5, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // Office furniture
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b6914,
            roughness: 0.6,
            metalness: 0.1
        });

        const metalMaterial = new THREE.MeshStandardMaterial({
            color: 0x404040,
            roughness: 0.3,
            metalness: 0.8
        });

        // Create detailed desks
        function createDesk(x, z) {
            const deskGroup = new THREE.Group();

            // Desk top
            const deskTop = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.1, 1.5),
                woodMaterial
            );
            deskTop.position.y = 0.75;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            deskGroup.add(deskTop);

            // Metal frame
            const frameGeometry = new THREE.BoxGeometry(0.05, 0.7, 0.05);
            const framePositions = [
                [-1.45, 0.35, -0.7],
                [1.45, 0.35, -0.7],
                [-1.45, 0.35, 0.7],
                [1.45, 0.35, 0.7]
            ];

            framePositions.forEach(pos => {
                const frame = new THREE.Mesh(frameGeometry, metalMaterial);
                frame.position.set(...pos);
                frame.castShadow = true;
                deskGroup.add(frame);
            });

            // Computer monitor
            const monitorBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16),
                metalMaterial
            );
            monitorBase.position.set(0, 0.82, 0);
            deskGroup.add(monitorBase);

            const monitorStand = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 0.3, 0.05),
                metalMaterial
            );
            monitorStand.position.set(0, 0.95, 0);
            deskGroup.add(monitorStand);

            const monitorScreen = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.7, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 })
            );
            monitorScreen.position.set(0, 1.3, 0);
            deskGroup.add(monitorScreen);

            // Keyboard
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.02, 0.15),
                metalMaterial
            );
            keyboard.position.set(0, 0.81, 0.3);
            deskGroup.add(keyboard);

            // Chair
            const chairSeat = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.05, 0.5),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairSeat.position.set(0, 0.5, 0.8);
            deskGroup.add(chairSeat);

            const chairBack = new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 0.6, 0.05),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            chairBack.position.set(0, 0.8, 1.02);
            deskGroup.add(chairBack);

            // Random desk items
            if (Math.random() > 0.5) {
                // Coffee mug
                const mug = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.1, 8),
                    new THREE.MeshStandardMaterial({ color: 0xffffff })
                );
                mug.position.set(Math.random() * 0.5 - 0.25, 0.85, Math.random() * 0.3);
                deskGroup.add(mug);
            }

            deskGroup.position.set(x, 0, z);
            return deskGroup;
        }

        // Add desks for co-founders
        const desk1 = createDesk(-10, -10);
        const desk2 = createDesk(10, -10);
        scene.add(desk1, desk2);

        // Add whiteboard
        const whiteboardMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.2,
            metalness: 0.1
        });

        const whiteboard = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 0.1),
            whiteboardMaterial
        );
        whiteboard.position.set(0, 3, -19.8);
        whiteboard.castShadow = true;
        scene.add(whiteboard);

        // Plant decorations
        const plantPot = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.25, 0.4, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        plantPot.position.set(-15, 0.2, -15);
        scene.add(plantPot);

        const plantLeaves = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 6, 5),
            new THREE.MeshStandardMaterial({ color: 0x228b22 })
        );
        plantLeaves.position.set(-15, 0.8, -15);
        scene.add(plantLeaves);

        // Add more plants
        const plantPot2 = plantPot.clone();
        plantPot2.position.set(15, 0.2, -15);
        scene.add(plantPot2);

        const plantLeaves2 = plantLeaves.clone();
        plantLeaves2.position.set(15, 0.8, -15);
        scene.add(plantLeaves2);

        // Add coffee station
        const coffeeTable = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.8, 1),
            woodMaterial
        );
        coffeeTable.position.set(-18, 0.4, 10);
        coffeeTable.castShadow = true;
        scene.add(coffeeTable);

        const coffeeMachine = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.5, 0.3),
            metalMaterial
        );
        coffeeMachine.position.set(-18, 1.05, 10);
        scene.add(coffeeMachine);

        // Character creation with more detail
        const characters = [];

        function createCharacter(name, role, x, z, shirtColor, characterData) {
            const group = new THREE.Group();

            // Torso
            const torsoGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.8, 8);
            const torsoMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });
            const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
            torso.position.y = 0.6;
            torso.castShadow = true;
            group.add(torso);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
            const armMaterial = new THREE.MeshStandardMaterial({ color: shirtColor });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.3, 0.7, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.3, 0.7, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });

            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.4, 0);
            group.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.4, 0);
            group.add(rightLeg);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.25, 8, 6);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.25;
            head.castShadow = true;
            group.add(head);

            // Hair
            const hairGeometry = new THREE.SphereGeometry(0.27, 8, 6);
            const hairMaterial = new THREE.MeshStandardMaterial({ color: characterData.hairColor });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 1.35;
            hair.scale.y = 0.6;
            group.add(hair);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.03, 4, 4);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.25, 0.22);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.25, 0.22);
            group.add(rightEye);

            // Add glasses if character has them
            if (characterData.hasGlasses) {
                const glassesMaterial = new THREE.MeshStandardMaterial({
                    color: 0x333333,
                    metalness: 0.5,
                    roughness: 0.3
                });

                // Left frame
                const leftFrame = new THREE.Mesh(
                    new THREE.TorusGeometry(0.08, 0.01, 8, 16),
                    glassesMaterial
                );
                leftFrame.position.set(-0.08, 1.25, 0.22);
                leftFrame.rotation.y = Math.PI / 2;
                group.add(leftFrame);

                // Right frame
                const rightFrame = new THREE.Mesh(
                    new THREE.TorusGeometry(0.08, 0.01, 8, 16),
                    glassesMaterial
                );
                rightFrame.position.set(0.08, 1.25, 0.22);
                rightFrame.rotation.y = Math.PI / 2;
                group.add(rightFrame);

                // Bridge
                const bridge = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.01, 0.01, 0.1, 8),
                    glassesMaterial
                );
                bridge.position.set(0, 1.25, 0.22);
                bridge.rotation.z = Math.PI / 2;
                group.add(bridge);

                // Temples (arms)
                const templeGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 8);

                const leftTemple = new THREE.Mesh(templeGeometry, glassesMaterial);
                leftTemple.position.set(-0.16, 1.25, 0.15);
                leftTemple.rotation.set(0, -Math.PI / 4, Math.PI / 2);
                group.add(leftTemple);

                const rightTemple = new THREE.Mesh(templeGeometry, glassesMaterial);
                rightTemple.position.set(0.16, 1.25, 0.15);
                rightTemple.rotation.set(0, Math.PI / 4, Math.PI / 2);
                group.add(rightTemple);
            }

            // Name label
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, 256, 64);
            context.fillStyle = 'black';
            context.font = 'bold 20px Arial';
            context.textAlign = 'center';
            context.fillText(name, 128, 25);
            context.font = '16px Arial';
            context.fillStyle = '#666';
            context.fillText(role, 128, 45);

            const texture = new THREE.CanvasTexture(canvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: texture });
            const label = new THREE.Sprite(labelMaterial);
            label.position.y = 1.8;
            label.scale.set(2, 0.5, 1);
            group.add(label);

            group.position.set(x, 0, z);
            group.userData = {
                name,
                role,
                conversations: [],
                initialPosition: new THREE.Vector3(x, 0, z),
                targetPosition: new THREE.Vector3(x, 0, z),
                moveTimer: 0,
                isDancing: false,
                tripChance: 0.001,
                leftArm: leftArm,
                rightArm: rightArm,
                ...characterData
            };

            characters.push(group);
            return group;
        }

        // Add Darshana co-founders
        const natalie = createCharacter('Natalie Gil', 'CTO & Co-founder', -8, -5, 0x9370db, {
            hairColor: 0x3d3d3d,
            personality: 'technical genius and innovator',
            quirk: 'always has brilliant tech solutions while adjusting her glasses',
            hasGlasses: true
        });

        const silvana = createCharacter('Silvana Lopez', 'CEO & Co-founder', 8, -5, 0xff69b4, {
            hairColor: 0xf5deb3,
            personality: 'visionary leader and strategist',
            quirk: 'turns every challenge into a game-changing opportunity',
            hasGlasses: false
        });

        scene.add(natalie, silvana);

        // Get references to input elements early
        const customQuestionInput = document.getElementById('custom-question-input');
        const customQuestionSubmit = document.getElementById('custom-question-submit');

        // Player controls
        const player = {
            position: new THREE.Vector3(0, 1.6, 5),
            velocity: new THREE.Vector3(0, 0, 0),
            speed: 0.1,
            rotation: 0,
            isDancing: false
        };

        const keys = {};

        document.addEventListener('keydown', (e) => {
            // Don't process game controls if typing in the custom question input
            if (document.activeElement === customQuestionInput) {
                // Only process ESC when typing
                if (e.key === 'Escape') {
                    dialogueBox.style.display = 'none';
                    currentCharacter = null;
                    if (document.pointerLockElement === renderer.domElement) {
                        document.exitPointerLock();
                    }
                }
                return;
            }

            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true; // Store original key for arrow keys

            if (e.key.toLowerCase() === 'e' && nearbyCharacter && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                openDialogue(nearbyCharacter);
            }

            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                e.preventDefault();
                player.isDancing = true;
                createFloatingText('üíÉüï∫', player.position);
            }

            if (e.key === 'Escape') {
                dialogueBox.style.display = 'none';
                currentCharacter = null;
                if (document.pointerLockElement === renderer.domElement) {
                    document.exitPointerLock();
                }
            }

            // Prevent arrow keys from scrolling the page
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            // Don't process game controls if typing in the custom question input
            if (document.activeElement === customQuestionInput) {
                return;
            }

            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false; // Clear original key for arrow keys

            if (e.key === ' ' && dialogueBox.style.display !== 'block') {
                player.isDancing = false;
            }
        });

        // Character movement AI
        function updateCharacterMovement(character, deltaTime) {
            // Don't move if this character is in conversation or dancing
            if (character === currentCharacter || character.userData.isDancing) {
                if (character === currentCharacter) {
                    // Face the player
                    const lookTarget = new THREE.Vector3(player.position.x, character.position.y, player.position.z);
                    character.lookAt(lookTarget);
                    character.rotation.x = 0;
                    character.rotation.z = 0;
                }
                return;
            }

            // Random dance party
            if (Math.random() < 0.001) {
                character.userData.isDancing = true;
                createFloatingText('üéµ', character.position);
                setTimeout(() => {
                    character.userData.isDancing = false;
                }, 3000);
            }

            character.userData.moveTimer -= deltaTime;

            if (character.userData.moveTimer <= 0) {
                // Set new random target
                const angle = Math.random() * Math.PI * 2;
                const distance = 3 + Math.random() * 5;
                character.userData.targetPosition = new THREE.Vector3(
                    character.userData.initialPosition.x + Math.cos(angle) * distance,
                    0,
                    character.userData.initialPosition.z + Math.sin(angle) * distance
                );

                // Keep within bounds
                character.userData.targetPosition.x = Math.max(-18, Math.min(18, character.userData.targetPosition.x));
                character.userData.targetPosition.z = Math.max(-18, Math.min(18, character.userData.targetPosition.z));

                character.userData.moveTimer = 5 + Math.random() * 5;
            }

            // Move towards target
            const direction = new THREE.Vector3().subVectors(character.userData.targetPosition, character.position);
            direction.y = 0;
            const distance = direction.length();

            if (distance > 0.1) {
                direction.normalize();
                character.position.add(direction.multiplyScalar(0.02));

                // Face movement direction
                character.lookAt(character.userData.targetPosition);
                character.rotation.x = 0;
                character.rotation.z = 0;

                // Walking animation
                if (!character.userData.isDancing) {
                    character.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
                }
            }
        }

        // Dialogue system
        const dialogueBox = document.getElementById('dialogue-box');
        const dialogueName = document.getElementById('dialogue-name');
        const dialogueContent = document.getElementById('dialogue-content');
        const dialogueOptions = document.getElementById('dialogue-options');
        const interactionPrompt = document.getElementById('interaction-prompt');

        let currentCharacter = null;
        let nearbyCharacter = null;

        function generateDialogueOptions(character) {
            // Questions specific to Darshana co-founders
            const allQuestions = [
                // About their role at Darshana
                "Tell me about your role at Darshana",
                "What's a typical day like for you?",
                "What's the most challenging part of building Darshana?",
                "How did you two decide to start Darshana together?",

                // About Darshana's mission
                "What's your vision for Darshana?",
                "How is Darshana different from other HR tech companies?",
                "What problem are you solving with Darshana?",
                "Tell me about responsible AI in hiring",

                // About the technology
                "What technology powers Darshana?",
                "How do you ensure AI fairness in hiring?",
                "What's your approach to data privacy?",
                "How does verified credentials work?",

                // Fun questions
                "What's your favorite feature in Darshana?",
                "Do you use AI to hire at Darshana?",
                "What's the funniest interview story you've heard?",
                "Coffee or tea?",
                "What's your favorite productivity hack?",
                "How do you handle work-life balance?",

                // Deep questions
                "What keeps you up at night about AI?",
                "Where do you see Darshana in 5 years?",
                "What advice would you give to aspiring founders?",
                "What's the best decision you've made at Darshana?"
            ];

            // Select 4 random questions
            const shuffled = allQuestions.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 4);
        }

        function openDialogue(character) {
            currentCharacter = character;
            dialogueBox.style.display = 'block';
            dialogueName.textContent = `${character.userData.name} - ${character.userData.role}`;

            // Exit pointer lock when opening dialogue
            if (document.pointerLockElement === renderer.domElement) {
                document.exitPointerLock();
            }

            const greetings = [
                `Hello! I'm ${character.userData.name}, ${character.userData.role} at Darshana. Ask me anything!`,
                `Oh hey! I'm ${character.userData.name}. Just ${character.userData.quirk}, as usual.`,
                `Hi there! ${character.userData.name} here. What can I tell you about Darshana?`,
                `Great to meet you! I'm ${character.userData.name}. ${character.userData.quirk}!`
            ];

            if (character.userData.conversations.length === 0) {
                dialogueContent.innerHTML = `<p><strong>${character.userData.name}:</strong> ${greetings[Math.floor(Math.random() * greetings.length)]}</p>`;
            } else {
                // Show last exchange
                const lastConv = character.userData.conversations[character.userData.conversations.length - 1];
                dialogueContent.innerHTML = `<p><strong>You:</strong> ${lastConv.user}</p><p><strong>${character.userData.name}:</strong> ${lastConv.response}</p>`;
            }

            // Generate dialogue options
            const options = generateDialogueOptions(character);
            dialogueOptions.innerHTML = '';

            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'dialogue-option';
                optionDiv.textContent = option;
                optionDiv.onclick = () => selectOption(option);
                dialogueOptions.appendChild(optionDiv);
            });

            // Clear custom question input
            customQuestionInput.value = '';

            // Focus the input for easy typing
            setTimeout(() => {
                customQuestionInput.focus();
            }, 100);
        }

        function generateResponse(character, question) {
            // Simple response generator based on character
            if (character.userData.name === 'Natalie Gil') {
                const natalieResponses = [
                    "As CTO, I focus on building scalable, secure technology. At Darshana, we're using AI to make hiring more fair and transparent.",
                    "Technology should solve real problems. That's why we built Darshana - to fix bias in hiring with verified credentials and responsible AI.",
                    "I love working with cutting-edge tech! At Darshana, we're combining blockchain, AI, and data science to revolutionize HR.",
                    "*Adjusts glasses* The technical challenges at Darshana are fascinating. We're building systems that need to be both powerful and ethical."
                ];
                return natalieResponses[Math.floor(Math.random() * natalieResponses.length)];
            } else if (character.userData.name === 'Silvana Lopez') {
                const silvanaResponses = [
                    "As CEO, I'm focused on our vision: making hiring fair for everyone. Darshana is about trust, transparency, and opportunity.",
                    "Every challenge is an opportunity! At Darshana, we're not just building a product - we're changing how people find meaningful work.",
                    "I believe in the power of diverse teams. That's why Darshana fights bias with data-driven, responsible AI.",
                    "Leadership is about empowering others. At Darshana, we're empowering both candidates and employers with better tools."
                ];
                return silvanaResponses[Math.floor(Math.random() * silvanaResponses.length)];
            }

            return "That's a great question! Let me think about that...";
        }

        async function selectOption(option) {
            if (!currentCharacter) return;

            // Show selected option
            dialogueContent.innerHTML += `<p><strong>You:</strong> ${option}</p>`;
            dialogueContent.innerHTML += `<p><strong>${currentCharacter.userData.name}:</strong> <span class="loading"></span></p>`;

            // Scroll to bottom of dialogue
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Disable options during loading
            dialogueOptions.style.pointerEvents = 'none';
            dialogueOptions.style.opacity = '0.5';
            customQuestionInput.disabled = true;
            customQuestionSubmit.disabled = true;

            let responseText = generateResponse(currentCharacter, option);

            // Simulate thinking time
            await new Promise(resolve => setTimeout(resolve, 800));

            // Update conversation
            currentCharacter.userData.conversations.push({
                user: option,
                response: responseText
            });

            // Update display
            dialogueContent.innerHTML = dialogueContent.innerHTML.replace(
                '<span class="loading"></span>',
                responseText
            );

            // Scroll to bottom
            dialogueContent.scrollTop = dialogueContent.scrollHeight;

            // Random dialogue events
            if (Math.random() < 0.2) {
                createFloatingText('üí°', currentCharacter.position);
            }

            // Generate new options
            const newOptions = generateDialogueOptions(currentCharacter);
            dialogueOptions.innerHTML = '';

            newOptions.forEach(opt => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'dialogue-option';
                optionDiv.textContent = opt;
                optionDiv.onclick = () => selectOption(opt);
                dialogueOptions.appendChild(optionDiv);
            });

            // Re-enable options
            dialogueOptions.style.pointerEvents = 'auto';
            dialogueOptions.style.opacity = '1';
            customQuestionInput.disabled = false;
            customQuestionSubmit.disabled = false;
            customQuestionInput.focus();
        }

        // Custom question handler
        customQuestionSubmit.addEventListener('click', () => {
            const question = customQuestionInput.value.trim();
            if (question && currentCharacter) {
                selectOption(question);
            }
        });

        customQuestionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const question = customQuestionInput.value.trim();
                if (question && currentCharacter) {
                    selectOption(question);
                }
            }
        });

        // Animation loop
        let lastTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;

            // Update player movement
            if (dialogueBox.style.display !== 'block') {
                const moveVector = new THREE.Vector3(0, 0, 0);

                if (keys['w']) moveVector.z -= 1;
                if (keys['s']) moveVector.z += 1;
                if (keys['a']) moveVector.x -= 1;
                if (keys['d']) moveVector.x += 1;

                if (keys['ArrowLeft']) player.rotation += 0.05;
                if (keys['ArrowRight']) player.rotation -= 0.05;

                if (moveVector.length() > 0) {
                    moveVector.normalize();
                    moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation);
                    moveVector.multiplyScalar(player.speed);

                    const newPos = player.position.clone().add(moveVector);

                    // Keep within bounds
                    if (Math.abs(newPos.x) < 19 && Math.abs(newPos.z) < 19) {
                        player.position.copy(newPos);
                    }
                }

                // Dancing animation
                if (player.isDancing) {
                    player.position.y = 1.6 + Math.sin(currentTime * 0.01) * 0.2;
                }
            }

            // Update camera
            camera.position.copy(player.position);
            camera.rotation.y = player.rotation;

            // Update characters
            characters.forEach(character => {
                updateCharacterMovement(character, deltaTime);

                // Dancing animation
                if (character.userData.isDancing) {
                    character.position.y = Math.sin(currentTime * 0.01) * 0.2;
                    character.rotation.y += 0.05;
                }
            });

            // Check for nearby characters
            nearbyCharacter = null;
            characters.forEach(character => {
                const distance = player.position.distanceTo(character.position);
                if (distance < 2) {
                    nearbyCharacter = character;
                }
            });

            if (nearbyCharacter && dialogueBox.style.display !== 'block') {
                interactionPrompt.style.display = 'block';
                interactionPrompt.textContent = `Press E to talk to ${nearbyCharacter.userData.name}`;
            } else {
                interactionPrompt.style.display = 'none';
            }

            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
